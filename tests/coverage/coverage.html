
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/DKhorkov/hmtm-sso/internal/config/config.go (0.0%)</option>
				
				<option value="file1">github.com/DKhorkov/hmtm-sso/internal/database/connector.go (59.1%)</option>
				
				<option value="file2">github.com/DKhorkov/hmtm-sso/internal/database/utils.go (100.0%)</option>
				
				<option value="file3">github.com/DKhorkov/hmtm-sso/internal/errors/auth_errors.go (0.0%)</option>
				
				<option value="file4">github.com/DKhorkov/hmtm-sso/internal/errors/database_errors.go (0.0%)</option>
				
				<option value="file5">github.com/DKhorkov/hmtm-sso/internal/errors/jwt_errors.go (0.0%)</option>
				
				<option value="file6">github.com/DKhorkov/hmtm-sso/internal/errors/users_errors.go (0.0%)</option>
				
				<option value="file7">github.com/DKhorkov/hmtm-sso/internal/repositories/auth_repository.go (83.3%)</option>
				
				<option value="file8">github.com/DKhorkov/hmtm-sso/internal/repositories/users_repository.go (89.7%)</option>
				
				<option value="file9">github.com/DKhorkov/hmtm-sso/internal/security/hashing.go (100.0%)</option>
				
				<option value="file10">github.com/DKhorkov/hmtm-sso/internal/security/jwt.go (86.7%)</option>
				
				<option value="file11">github.com/DKhorkov/hmtm-sso/pkg/logging/logging.go (0.0%)</option>
				
				<option value="file12">github.com/DKhorkov/hmtm-sso/tests/config/test_config.go (100.0%)</option>
				
				<option value="file13">github.com/DKhorkov/hmtm-sso/tests/internal/repositories/lifespan/lifespan.go (65.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "time"

        "github.com/DKhorkov/hmtm-bff/pkg/loadenv"
)

func New() *Config <span class="cov0" title="0">{
        return &amp;Config{
                HTTP: HTTPConfig{
                        Host: loadenv.GetEnv("HOST", "0.0.0.0"),
                        Port: loadenv.GetEnvAsInt("PORT", 8070),
                },
                Security: SecurityConfig{
                        HashCost: loadenv.GetEnvAsInt("HASH_COST", 8), // Auth speed sensitive if large
                        JWT: JWTConfig{
                                TTL: time.Hour * time.Duration(
                                        loadenv.GetEnvAsInt("JWT_TTL", 24),
                                ),
                                Algorithm: loadenv.GetEnv("JWT_ALGORITHM", "HS256"),
                                SecretKey: loadenv.GetEnv("JWT_SECRET", "defaultSecret"),
                        },
                },
                Databases: DatabasesConfig{
                        PostgreSQL: DatabaseConfig{
                                Host:         loadenv.GetEnv("POSTGRES_HOST", "0.0.0.0"),
                                Port:         loadenv.GetEnvAsInt("POSTGRES_PORT", 5432),
                                User:         loadenv.GetEnv("POSTGRES_USER", "postgres"),
                                Password:     loadenv.GetEnv("POSTGRES_PASSWORD", "postgres"),
                                DatabaseName: loadenv.GetEnv("POSTGRES_DB", "postgres"),
                                SSLMode:      loadenv.GetEnv("POSTGRES_SSL_MODE", "disable"),
                                Driver:       loadenv.GetEnv("POSTGRES_DRIVER", "postgres"),
                        },
                },
        }
}</span>

type HTTPConfig struct {
        Host string
        Port int
}

type JWTConfig struct {
        SecretKey string
        Algorithm string
        TTL       time.Duration
}

type SecurityConfig struct {
        HashCost int
        JWT      JWTConfig
}

type DatabaseConfig struct {
        Host         string
        Port         int
        User         string
        Password     string
        DatabaseName string
        SSLMode      string
        Driver       string
}

type DatabasesConfig struct {
        PostgreSQL DatabaseConfig
        MySQL      DatabaseConfig
        SQLite     DatabaseConfig
}

type Config struct {
        HTTP      HTTPConfig
        Security  SecurityConfig
        Databases DatabasesConfig
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "log/slog"

        customerrors "github.com/DKhorkov/hmtm-sso/internal/errors"

        "github.com/DKhorkov/hmtm-sso/internal/config"
        "github.com/DKhorkov/hmtm-sso/pkg/logging"

        _ "github.com/lib/pq" // Postgres driver
)

type CommonDBConnector struct {
        Connection *sql.DB
        Driver     string
        DSN        string
        Logger     *slog.Logger
}

func (connector *CommonDBConnector) Connect() error <span class="cov8" title="1">{
        if connector.Connection == nil </span><span class="cov8" title="1">{
                connection, err := sql.Open(connector.Driver, connector.DSN)

                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">connector.Connection = connection</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (connector *CommonDBConnector) GetConnection() *sql.DB <span class="cov8" title="1">{
        if connector.Connection == nil </span><span class="cov8" title="1">{
                if err := connector.Connect(); err != nil </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }

        <span class="cov8" title="1">return connector.Connection</span>
}

func (connector *CommonDBConnector) GetTransaction() (*sql.Tx, error) <span class="cov8" title="1">{
        if connector.Connection == nil </span><span class="cov8" title="1">{
                return nil, &amp;customerrors.NilDBConnectionError{}
        }</span>

        <span class="cov8" title="1">return connector.Connection.Begin()</span>
}

func (connector *CommonDBConnector) CloseConnection() <span class="cov0" title="0">{
        if connector.Connection == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if err := connector.Connection.Close(); err != nil </span><span class="cov0" title="0">{
                connector.Logger.Error(
                        "Failed to close database connection",
                        "Traceback",
                        logging.GetLogTraceback(),
                        "Error",
                        err,
                )
        }</span>
}

func New(dbConfig config.DatabaseConfig, logger *slog.Logger) (*CommonDBConnector, error) <span class="cov0" title="0">{
        dsn := fmt.Sprintf(
                "host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                dbConfig.Host,
                dbConfig.Port,
                dbConfig.User,
                dbConfig.Password,
                dbConfig.DatabaseName,
                dbConfig.SSLMode,
        )

        dbConnector := &amp;CommonDBConnector{
                Driver: dbConfig.Driver,
                DSN:    dsn,
                Logger: logger,
        }

        if err := dbConnector.Connect(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return dbConnector, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package database

import (
        "reflect"
)

// GetEntityColumns receives a POINTER on entity (NOT A VALUE), parses is using reflection and returns
// a slice of columns for database/sql Query() method purpose for retrieving data from result rows.
// https://stackoverflow.com/questions/56525471/how-to-use-rows-scan-of-gos-database-sql
func GetEntityColumns(entity interface{}) []interface{} <span class="cov8" title="1">{
        structure := reflect.ValueOf(entity).Elem()
        numCols := structure.NumField()
        columns := make([]interface{}, numCols)
        for i := range numCols </span><span class="cov8" title="1">{
                field := structure.Field(i)
                columns[i] = field.Addr().Interface()
        }</span>

        <span class="cov8" title="1">return columns</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package errors

type InvalidPasswordError struct {
        message string
}

func (e *InvalidPasswordError) Error() string <span class="cov0" title="0">{
        if e.message != "" </span><span class="cov0" title="0">{
                return e.message
        }</span>

        <span class="cov0" title="0">return "invalid password"</span>
}

type UserAlreadyExistsError struct {
        message string
}

func (e *UserAlreadyExistsError) Error() string <span class="cov0" title="0">{
        if e.message != "" </span><span class="cov0" title="0">{
                return e.message
        }</span>

        <span class="cov0" title="0">return "user with provided email already exists"</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package errors

type NilDBConnectionError struct {
        message string
}

func (e NilDBConnectionError) Error() string <span class="cov0" title="0">{
        if e.message != "" </span><span class="cov0" title="0">{
                return e.message
        }</span>

        <span class="cov0" title="0">return "DB connection error. Making operation on nil database connection."</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package errors

type InvalidJWTError struct {
        message string
}

func (e *InvalidJWTError) Error() string <span class="cov0" title="0">{
        if e.message != "" </span><span class="cov0" title="0">{
                return e.message
        }</span>

        <span class="cov0" title="0">return "JWT token is invalid or has expired"</span>
}

type JWTClaimsError struct {
        message string
}

func (e *JWTClaimsError) Error() string <span class="cov0" title="0">{
        if e.message != "" </span><span class="cov0" title="0">{
                return e.message
        }</span>

        <span class="cov0" title="0">return "JWT claims error"</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package errors

type UserNotFoundError struct {
        message string
}

func (e *UserNotFoundError) Error() string <span class="cov0" title="0">{
        if e.message != "" </span><span class="cov0" title="0">{
                return e.message
        }</span>

        <span class="cov0" title="0">return "user not found"</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package repositories

import (
        "github.com/DKhorkov/hmtm-sso/entities"
        "github.com/DKhorkov/hmtm-sso/internal/interfaces"
)

type CommonAuthRepository struct {
        DBConnector interfaces.DBConnector
}

func (repo *CommonAuthRepository) RegisterUser(userData entities.RegisterUserDTO) (int, error) <span class="cov8" title="1">{
        var userID int
        connection := repo.DBConnector.GetConnection()
        err := connection.QueryRow(
                `
                        INSERT INTO users (email, password) 
                        VALUES ($1, $2)
                        RETURNING users.id
                `,
                userData.Credentials.Email,
                userData.Credentials.Password,
        ).Scan(&amp;userID)

        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return userID, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package repositories

import (
        "github.com/DKhorkov/hmtm-sso/entities"
        "github.com/DKhorkov/hmtm-sso/internal/database"
        customerrors "github.com/DKhorkov/hmtm-sso/internal/errors"
        "github.com/DKhorkov/hmtm-sso/internal/interfaces"
)

type CommonUsersRepository struct {
        DBConnector interfaces.DBConnector
}

func (repo *CommonUsersRepository) GetUserByID(id int) (*entities.User, error) <span class="cov8" title="1">{
        user := &amp;entities.User{}
        columns := database.GetEntityColumns(user)
        connection := repo.DBConnector.GetConnection()
        err := connection.QueryRow(
                `
                        SELECT * 
                        FROM users AS u
                        WHERE u.id = $1
                `,
                id,
        ).Scan(columns...)

        if err != nil </span><span class="cov8" title="1">{
                return nil, &amp;customerrors.UserNotFoundError{}
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

func (repo *CommonUsersRepository) GetUserByEmail(email string) (*entities.User, error) <span class="cov8" title="1">{
        user := &amp;entities.User{}
        columns := database.GetEntityColumns(user)
        connection := repo.DBConnector.GetConnection()
        err := connection.QueryRow(
                `
                        SELECT * 
                        FROM users AS u
                        WHERE u.email = $1
                `,
                email,
        ).Scan(columns...)

        if err != nil </span><span class="cov8" title="1">{
                return nil, &amp;customerrors.UserNotFoundError{}
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

func (repo *CommonUsersRepository) GetAllUsers() ([]*entities.User, error) <span class="cov8" title="1">{
        connection := repo.DBConnector.GetConnection()
        rows, err := connection.Query(
                `
                        SELECT * 
                        FROM users
                `,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var users []*entities.User
        for rows.Next() </span><span class="cov8" title="1">{
                user := &amp;entities.User{}
                columns := database.GetEntityColumns(user)
                err = rows.Scan(columns...)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">users = append(users, user)</span>
        }

        <span class="cov8" title="1">if err = rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return users, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package security

import "golang.org/x/crypto/bcrypt"

func HashPassword(password string, hashCost int) (string, error) <span class="cov8" title="1">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), hashCost)
        return string(bytes), err
}</span>

func ValidateHashedPassword(password, hashedPassword string) bool <span class="cov8" title="1">{
        err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package security

import (
        "time"

        "github.com/DKhorkov/hmtm-sso/entities"
        customerrors "github.com/DKhorkov/hmtm-sso/internal/errors"
        "github.com/golang-jwt/jwt/v5"
)

func GenerateJWT(user *entities.User, secretKey string, ttl time.Duration, algorithm string) (string, error) <span class="cov8" title="1">{
        token := jwt.New(jwt.GetSigningMethod(algorithm))
        claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return "", &amp;customerrors.JWTClaimsError{}
        }</span>

        <span class="cov8" title="1">claims["userID"] = user.ID
        claims["exp"] = time.Now().Add(ttl).Unix()
        return token.SignedString([]byte(secretKey))</span>
}

func ParseJWT(tokenString, secretKey string) (int, error) <span class="cov8" title="1">{
        token, err := jwt.ParseWithClaims(tokenString, jwt.MapClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                return []byte(secretKey), nil
        }</span>)

        <span class="cov8" title="1">if err != nil || !token.Valid </span><span class="cov8" title="1">{
                return 0, &amp;customerrors.InvalidJWTError{}
        }</span>

        <span class="cov8" title="1">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return 0, &amp;customerrors.JWTClaimsError{}
        }</span>

        <span class="cov8" title="1">return int(claims["userID"].(float64)), nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package logging

import (
        "fmt"
        "log/slog"
        "os"
        "runtime"
        "sync"
)

var (
        instance *slog.Logger
        once     sync.Once

        LogLevels = struct {
                INFO, DEBUG, WARN, ERROR slog.Level
        }{
                INFO:  slog.LevelInfo,
                DEBUG: slog.LevelDebug,
                WARN:  slog.LevelWarn,
                ERROR: slog.LevelError,
        }
)

// GetInstance implemented as singleton pattern to get Logger instance, created once for whole app:.
func GetInstance(logLevel slog.Level) *slog.Logger <span class="cov0" title="0">{
        once.Do(func() </span><span class="cov0" title="0">{
                instance = slog.New(
                        slog.NewJSONHandler(
                                os.Stdout,
                                &amp;slog.HandlerOptions{
                                        Level: logLevel,
                                },
                        ),
                )
        }</span>)

        <span class="cov0" title="0">return instance</span>
}

// GetLogTraceback return a string with info about filename, function name and line
// https://stackoverflow.com/questions/25927660/how-to-get-the-current-function-name
func GetLogTraceback() string <span class="cov0" title="0">{
        pc, file, line, ok := runtime.Caller(1)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s on line %d: %s", "Unknown", 0, "Unknown")
        }</span>

        <span class="cov0" title="0">fn := runtime.FuncForPC(pc)
        if fn == nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s on line %d: %s", file, line, "Unknown")
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%s on line %d: %s", file, line, fn.Name())</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package testconfig

type TestDatabaseConfig struct {
        Driver        string
        DSN           string
        MigrationsDir string
}

type TestConfig struct {
        Database TestDatabaseConfig
}

func New() *TestConfig <span class="cov8" title="1">{
        return &amp;TestConfig{
                Database: TestDatabaseConfig{
                        Driver:        "sqlite3",
                        DSN:           "file::memory:?cache=shared", // "test.db" can be also used
                        MigrationsDir: "/internal/database/migrations",
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package testlifespan

import (
        "database/sql"
        "os"
        "path"
        "testing"

        testconfig "github.com/DKhorkov/hmtm-sso/tests/config"
        "github.com/pressly/goose/v3"
)

var testsConfig = testconfig.New()

func StartUp(t *testing.T) *sql.DB <span class="cov8" title="1">{
        connection, err := sql.Open(testsConfig.Database.Driver, testsConfig.Database.DSN)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to connect to database: %v", err)
        }</span>

        <span class="cov8" title="1">if err = goose.SetDialect(testsConfig.Database.Driver); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to get cwd: %v", err)
        }</span>

        <span class="cov8" title="1">err = goose.Up(
                connection,
                path.Dir(
                        path.Dir(
                                path.Dir(cwd),
                        ),
                )+testsConfig.Database.MigrationsDir,
        )

        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">return connection</span>
}

func TearDown(t *testing.T, connection *sql.DB) <span class="cov8" title="1">{
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to get cwd: %v", err)
        }</span>

        <span class="cov8" title="1">err = goose.Down(
                connection,
                path.Dir(
                        path.Dir(
                                path.Dir(cwd),
                        ),
                )+testsConfig.Database.MigrationsDir,
        )

        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">if err = connection.Close(); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to close the connection to the database: %v", err)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
